<!-- https://dmegy.perso.math.cnrs.fr/illus/brazuca.html -->
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Brazuca</title>
<!-- <link href="../css/bootstrap5.min.css" rel="stylesheet"> -->
<style>
	body{
		padding:0;
		margin:0;
		width:100%;
		min-height: 100vh;
		background-color:#444444;
	}
	.container{
		/* width : min(95vw,500px); */

		min-height: 100vh;
		border:0 1px black solid;
		background-color: white;
		box-shadow: 0 0 15px black;
		padding : 1em;
	}
</style>
<script type="text/javascript" src="./algebra.js"></script>
<script type="text/javascript" src="./main.js"></script>

</head>
<body onload="commencer()">
	<div class="container">
	<center>Le Brazuca, le ballon de la coupe du monde 2014, n'est pas un <a href="http://fr.wikipedia.org/wiki/Icosa%C3%A8dre_tronqu%C3%A9">icosaèdre tronqué</a>, c'est un recollement de surfaces réglées.<br/>
<div id="candiv" style="width: 400px; height: 400px;">
<canvas id="canvas" width="400" height="400">
</canvas>
</div>
</center>


<p>
La source est un <a href="https://images.math.cnrs.fr/Le-Brazuca-le-ballon-cubique-de-la-Coupe-du-monde" target="_blank">billet d'Etienne Ghys sur le site image des maths</a>.
</p>

<h2>Making-of</h2>
<h4>Contexte</h4>
<p>
	Cette animation a été codée juste après avoir lu l'article, il y a bien longtemps. Comme il s'agissait de surfaces réglées recollées entre elles, la tentation était forte de coder quelque chose dans le genre des <a href="./index.html" target="_blank">autres animations de surfaces réglées</a>. Une surface réglée est une surface qui est entièrement recouverte par une famille de droites. Comme dessiner des droites en javascript est facile, on peut relativement facilement dessiner de telles surfaces avec un code très simple, n'utilisant que les "canvas" en html5 et en dessinant des segments.
	<center>
		<img src="conoidePlucker3.png">
	</center>
</p>
<h4>Construction des «faces»</h4>
D'après l'article d'Étienne Ghys, le ballon est obtenu en recollant six «faces», comme un cube. La différence est que ces faces ne sont pas de carrés, mais des formes un peu plus complexes. Les six faces sont toutes identiques, les voici (illustration tirée de l'article) :
<center>
	<img src="brazuca_patron.jpg" style="width:100%">
</center>
<p>Il fallait donc trouver une façon de dessiner ces formes avec javascript. 
<h4>Première utilisation des symétries</h4>
Noter que les faces ont une symétrie de rotation d'ordre quatre : il n'est donc nécessaire que de savoir dessiner une «ailette», (dans la suite, on eappellera ça une «tuile», et de dessiner les trois autres en appliquant des rotations successives d'un quart de tour.</p>
<h4>Fonctions pour la forme des tuiles</h4>
<p>Comme l'objectif était d'avoir un code qui permette d'augmenter facilement le nombre de traits (ou de le réduire, si on observe un ralentissement trop grand), le choix a été fait d'interpoler la forme du bord de la tuile avec des fonctions, c'était l'idée la plus simple. Après capture d'écran, zoom, et quelques tatonnements sur les coordonnées des points et des vecteurs, on obtient deux fonctions (définies par morceaux sur le segment [0,10] dans notre exemple), qui représentent le «haut» de la tuile, et le «bas» de la tuile :
<pre><code>
function haut(x){
	var r=0;
	if(0&lt;=x &amp;&amp; x&lt;= 1.5) r=x;
	if(1.5&lt;x &amp;&amp; x&lt;=2.5) r=1+0.5*(x-2.5)*(x-2.5);
	if(2.5&lt;x &amp;&amp; x&lt;=6.5) r=1+0.23*(x-2.5)*(x-2.5)-0.025*(x-2.5)*(x-2.5)*(x-2.5);//
	if(6.5&lt;x &amp;&amp; x&lt;=10) r=3*Math.sqrt((20-2*x)/7);
	return r;
}
function bas(x){
	var r=0;
	if(0&lt;= x &amp;&amp; x&lt;= 1.5) r=-x;
	if(1.5&lt; x &amp;&amp; x&lt;=2.5) r=-1-0.5*(x-2.5)*(x-2.5);
	if(2.5&lt;x &amp;&amp; x&lt;=6.5) r=-1;
	if(6.5&lt;x &amp;&amp; x&lt;=10) r=-Math.sqrt(1-((x-6.5)*(x-6.5))/(3.5*3.5));
	return r;
}
</code></pre>
C'est très moche, oui, mais c'était la première idée qui est venue et elle permet d'augmenter le nombre de traits à volonté. Illustration avec 20, 40 puis 60 traits:
<canvas id="canvas2" width="380" height="100" style="border:1px black solid;display:block;margin:1em auto">
</canvas>
<script>
	let canvas2 = document.getElementById("canvas2");
    ctx2 = canvas2.getContext("2d");
    function dessinerTuile(n,x,y,contexte){
    	for (let i=0;i<n;i++){
			contexte.beginPath();
			contexte.moveTo(x+10*i*10/n,y+10*bas(i*10/n));
			contexte.lineTo(x+10*i*10/n,y+10*haut(i*10/n));
			contexte.stroke();
		}
    }
    dessinerTuile(20,20,50,ctx2);
    dessinerTuile(40,140,50,ctx2);
    dessinerTuile(60,260,50,ctx2);

    
</script>
Pour dessiner une face, il suffit de dessiner quatre tuiles en les faisant tourner d'un quart de tour à chaque fois, ce qui donne:
<canvas id="canvas3" width="240" height="240" style="border:1px black solid;display:block;margin:1em auto">
</canvas>
<script>

	let canvas3 = document.getElementById("canvas3");
    ctx3 = canvas3.getContext("2d");
    let N=40,x0=120,y0=120;
	for (let i=0;i<N;i++){
		ctx3.beginPath();
		ctx3.moveTo(x0+10*i*10/N,y0+10*bas(i*10/N));
		ctx3.lineTo(x0+10*i*10/N,y0+10*haut(i*10/N));

		ctx3.moveTo(y0-10*bas(i*10/N),x0+10*i*10/N);
		ctx3.lineTo(y0-10*haut(i*10/N),x0+10*i*10/N);

		ctx3.moveTo(x0-10*i*10/N,y0-10*bas(i*10/N));
		ctx3.lineTo(x0-10*i*10/N,y0-10*haut(i*10/N));

		ctx3.moveTo(y0+10*bas(i*10/N),x0-10*i*10/N);
		ctx3.lineTo(y0+10*haut(i*10/N),x0-10*i*10/N);

		ctx3.stroke();
	}
</script>
Toujours à comparer avec 
<center>
	<img src="brazuca_patron.jpg" style="width:100%">
</center>
(Les plus attentifs auront remarqué qu'il y a une différence,  et que donc la face n'est pas exactement la même que le modèle original : c'est son symétrique. Ceci est dû au fait que les canvas html ont un système de coordonnées où les y vont «vers le bas»...)
</p>
<h4>Placement de toutes les tuiles/faces</h4>
Il suffit maintenant de savoir dessiner une tuile en trois dimensions, en la "pliant", puis de dessiner les 24 tuiles nécessaires, en prenant la première tuile et en appliquant chacune des 24 matrices de rotation suivantes:
<pre><code>
// le tableau G contient 24 matrices de rotation
let G=new Array();
G[0]=matriceRotation([1,0,0],PI/4-0.55);
for(let i=1;i&lt;4;i++)
	G.push(produitMatriciel(matriceRotation([1,0,0],PI/2),G[i-1]));
for(let i=0;i&lt;4;i++)
	G.push(produitMatriciel(matriceRotation([0,0,1],PI/2),G[i]));
for(let i=0;i&lt;4;i++)
	G.push(produitMatriciel(matriceRotation([0,1,0],PI/2),G[i]));
for(let i=0;i&lt;4;i++)
	G.push(produitMatriciel(matriceRotation([0,1,0],PI),G[i]));
for(let i=0;i&lt;4;i++)
	G.push(produitMatriciel(matriceRotation([0,0,1],-PI/2),G[i]));
for(let i=0;i&lt;4;i++)
	G.push(produitMatriciel(matriceRotation([0,1,0],-PI/2),G[i]));
	</code></pre>

<p>(Explication : on commence par les quatre rotations d'une face, puis on rajoute les rotations correspondant aux 5 autres faces, en prenant les quatres rotations de la première face et en les multipliant par des rotations d'un quart de tour, ou, pour la face opposée, par une rotation d'un demi-tour. Chacune des six boucles for correspond aux rotations d'une des six faces.)</p>

<p>Ce code utilise une fonction de multiplication de matrices, et une fonction <code>matriceRotation(vecteur,angle)</code> qui retourne une matrice orthogonale de rotation, dont le code est standard (voir cours de L2 sur les espaces euclidiens). On obtient les 24 matrices de rotations qui sont celles qu el'on doit appliquer à une tuile pour obtenir les 24 autres dans l'espace, de sorte qu'elles forent bien un "cube". Si la première tuile est convenablement courbée dans l'espace, on obtient quelque chose qui ressemble à une sphère, plutôt qu'à un cube.</p>
<h4>Animation</h4>
Le ballon est animé en tournant sur lui-même. À chaque nouvelle image, on applique à tous les points une rotation d'un centième de radian par rapport à un certain axe (ici <code>[1.5,0.1,1]</code>), et on redessine tous les traits.
<h4>Conclusion</h4>
<p>Il manque plein de détails mais ces courtes explications devraient rendre la lecture du code assez facile, ou en tout cas faisable. </p>
<p>Le code n'est ni très beau ni très optimisé, et je ne connaissais pas <code>requestAnimationFrame</code> à l'époque, par exemple, donc tout est fait avec un <code>setTimeout</code> toutes les 40ms, ce qui est une mauvaise pratique...Il y a plein d'autres défauts (syntaxe javascript pre-ES6 en général) mais il y a peu de chances que tout ceci soit mis à jour.</p>
</div>
</body>
</html>